{"meta":{"title":"云的空间","subtitle":"随笔，日记，博客，学习等集合体，打开它，总有收获","description":"永不停歇，探无止境","author":"云","url":"https://xiangwenhu.github.io"},"pages":[],"posts":[{"title":"koa-router源码分析","slug":"sourecode/koa-router","date":"2017-08-22T15:00:00.000Z","updated":"2017-08-23T08:44:10.396Z","comments":true,"path":"2017/08/22/sourecode/koa-router/","link":"","permalink":"https://xiangwenhu.github.io/2017/08/22/sourecode/koa-router/","excerpt":"","text":"koa-router源码地址是 koa-router当前解读版本为7.2.1Router 源码解析 和 Layer 源码解析 关系图代码结构图执行流程图关系对应图 Router方法和属性浅析methods.forEach注册注册路由的方法,结果就是Router的原型上面多了get,post,delete,del等注册路由的方法代码使用的时候 r1.get就是这么来的123456r1.get('/test1/:id', function (ctx, next) &#123; console.log('test1 :1') next()&#125;, function (ctx, next) &#123; console.log('test1:2')&#125;) Router.prototype.del等同于 Router.prototype.delete Router.prototype.use注册中间件，支持形式多种多样看着这么多，其实就两种中间件， 普通中间件 router.routes()返回的中间件 重点就是router.routes()返回的这种件，需要的前缀，参数验中间件做一些处理123456789101112131415161718router.use(function (ctx, next) &#123; ctx.foo = 'baz'; return next();&#125;);router.use('/foo/bar', function (ctx, next) &#123; ctx.foo = 'foo'; return next();&#125;);router.use('/foo', subrouter.routes());router.use(['/foo', '/bar'], function (ctx, next) &#123; ctx.foo = 'foo'; ctx.bar = 'bar'; return next(); &#125;);parentRouter.use('/parent-route', function (ctx, next) &#123; ctx.n = ctx.n ? (ctx.n + 1) : 1; return next();&#125;, nestedRouter.routes()); Router.prototype.prefix给router实例添加前缀，前缀可以是包含参数的1router.prefix('/things/:thing_id') Router.prototype.routes = Router.prototype.middleware返回中间件，中间执行的时候，会根据path获取满足匹配条件的路由(Layer),然后根据每个Layer生成一个解析参数值的中间，这就是为什么我们在ctx.params能得到参数值最核心的代码如下123456789layerChain = matchedLayers.reduce(function(memo, layer) &#123; memo.push(function(ctx, next) &#123; ctx.captures = layer.captures(path, ctx.captures); ctx.params = layer.params(path, ctx.captures, ctx.params); return next(); &#125;); return memo.concat(layer.stack);&#125;, []);return compose(layerChain)(ctx, next); matchedLayers是匹配的Layer或者说一条路由信息，同一个路径同样的方法也是会生成两条记录的,如下同样的注册，会生成两个不同路由(Layer),哪怕信息一模一样123456789r1.get('/test1', function (ctx, next) &#123; console.log('test1 :1') next()&#125;)r1.get('/test1', function (ctx, next) &#123; console.log('test1 :2') next()&#125;) matchedLayers.reduce没执行一次，是生成两个中间件，一个是参数解析的中间件,这就是为什么你可以通过ctx.params取值到路由参数了12345function(ctx, next) &#123; ctx.captures = layer.captures(path, ctx.captures); ctx.params = layer.params(path, ctx.captures, ctx.params); return next(); &#125; 另外一个才是实际路由匹配的执行方法,上面的demo就是1234function (ctx, next) &#123; console.log('test1 :1') next()&#125; Router.prototype.allowedMethods此方法执行很靠后，在他后面注册的中间件执行完毕后才执行生成一个中间件，作用是定义路由没匹配到，方法未允许，方法未实现等的返回信息123456app.use(router.routes());app.use(router.allowedMethods(&#123; throw: true, notImplemented: () =&gt; new Boom.notImplemented(), methodNotAllowed: () =&gt; new Boom.methodNotAllowed()&#125;)); Router.prototype.all注册一个路由，允许所有的get,post等方法访问 Router.prototype.redirect跳转，原理就是注册了一个路由，用ctx.redirect来实现跳转1router.redirect('/login', 'sign-in'); 等同于1234router.all('/login', function (ctx) &#123; ctx.redirect('/sign-in'); ctx.status = 301;&#125;); Router.prototype.register核心方法之一，注册中间件Router.prototype.all,methods.forEach等底层都是调用这个家伙实现的Router.prototype.use也依据情况会调用 Router.prototype.route查找具名的route(Layer) Router.prototype.url生成url，可以传参1234567891011router.get('user', '/users/:id', function (ctx, next) &#123; // ...&#125;);router.url('user', 3);// =&gt; \"/users/3\"router.url('user', &#123; id: 3 &#125;);// =&gt; \"/users/3\"router.use(function (ctx, next) &#123; // redirect to named route ctx.redirect(ctx.router.url('sign-in'));&#125;) Router.prototype.match获得匹配的路由(Layer),以path和method来过滤的router.routes返回的中间件底层就是通过他来确认请求应该进入哪些路由的 Router.prototype.param添加参数验证中间件，这个需要结合Layer.prototype.param 一起来理解1234567891011121314151617181920212223242526272829303132333435363738394041Router.prototype.param = function (param, middleware) &#123; this.params[param] = middleware; this.stack.forEach(function (route) &#123; route.param(param, middleware); &#125;); return this;&#125;;Layer.prototype.param = function (param, fn) &#123; var stack = this.stack; var params = this.paramNames; // 构建参数验证中间件 var middleware = function (ctx, next) &#123; return fn.call(this, ctx.params[param], ctx, next); &#125;; middleware.param = param; var names = params.map(function (p) &#123; return p.name; &#125;); var x = names.indexOf(param); if (x &gt; -1) &#123; // iterate through the stack, to figure out where to place the handler fn stack.some(function (fn, i) &#123; // param handlers are always first, so when we find an fn w/o a param property, stop here // if the param handler at this part of the stack comes after the one we are adding, stop here // fn.param 作为判断是不是参数验证中间件的标志 // 如果不是参数验证中间件，或者参数验证中间件需要验证的参数在我之后，插入参数验证中间件 // 比如说path是这样的 /user/:id/posts/:postid, 那么id参数验证中间件应该在postid参数之前 // 简单说，确保参数按照顺序被验证 if (!fn.param || names.indexOf(fn.param) &gt; x) &#123; // inject this param handler right before the current item stack.splice(i, 0, middleware); return true; // then break the loop &#125; &#125;); &#125; return this;&#125;; Layer方法和属性浅析Layer.prototype.matchpath是否匹配路由 Layer.prototype.params获得路由参数键值对 Layer.prototype.captures获得路由参数的值 Layer.prototype.url用参数构建URL,params参数可视是对象也可是数组 Layer.prototype.param添加参数验证中间件 Layer.prototype.setPrefix设置前缀 safeDecodeURIComponentdecodeURIComponent错误时返回原值 更多细节请直接看带备注的源码吧，写东西真累啊！Router 源码解析 和 Layer 源码解析 一些Notes koa-router支持链式调用router.get(&#39;user&#39;,fn).post(&#39;auth&#39;,fn)... 路由嵌套，请加上前缀，Koa-router 优先级问题 关于prefix,下面是等同的，如果你要路由嵌套，建议采用第二种，方便理解 1234567const Router = require('koa-router')var r1 = new Router(&#123; prefix: '/t'&#125;)......r2.use('', r1.routes())module.exports = r2 等同于 12345const Router = require('koa-router')var r1 = new Router()......r2.use('/', r1.routes())module.exports = r2 koa-router 源码解析 - segmentfault解析Koa-Router，迈入Web次时代第一步（上）Koa-Router 源码解析下 -CNodekoa-router源码解读 Koa-router 优先级问题Koa-router路由中间件API详解 Path-to-RegExp 使用","categories":[{"name":"源码","slug":"源码","permalink":"https://xiangwenhu.github.io/categories/源码/"}],"tags":[{"name":"koa-router","slug":"koa-router","permalink":"https://xiangwenhu.github.io/tags/koa-router/"}]},{"title":"koa-router Router源码分析","slug":"sourecode/koa-router-router","date":"2017-08-22T14:00:00.000Z","updated":"2017-08-23T08:42:25.594Z","comments":true,"path":"2017/08/22/sourecode/koa-router-router/","link":"","permalink":"https://xiangwenhu.github.io/2017/08/22/sourecode/koa-router-router/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749/** * RESTful resource routing middleware for koa. * * @author Alex Mingoia &lt;talk@alexmingoia.com&gt; * @link https://github.com/alexmingoia/koa-router */var debug = require('debug')('koa-router');var compose = require('koa-compose');var HttpError = require('http-errors');var methods = require('methods');var Layer = require('./layer');/** * @module koa-router */module.exports = Router;/** * Create a new router. * * @example * * Basic usage: * * ```javascript * var Koa = require('koa'); * var Router = require('koa-router'); * * var app = new Koa(); * var router = new Router(); * * router.get('/', function (ctx, next) &#123; * // ctx.router available * &#125;); * * app * .use(router.routes()) * .use(router.allowedMethods()); * ``` * * @alias module:koa-router * @param &#123;Object=&#125; opts * @param &#123;String=&#125; opts.prefix prefix router paths * @constructor */function Router(opts) &#123; if (!(this instanceof Router)) &#123; return new Router(opts); &#125; // opts.prefix 前缀 // opts.sensitive 带小写敏感,用于Layer的path-to-regexp 插件使用 // opts.strict 末尾斜杠是否精确匹配,用于Layer的path-to-regexp 插件使用 // opts.methods 支持的方法 this.opts = opts || &#123;&#125;; this.methods = this.opts.methods || [ 'HEAD', 'OPTIONS', 'GET', 'PUT', 'PATCH', 'POST', 'DELETE' ]; // 参数验证中间件 this.params = &#123;&#125;; // Layer, 路由 this.stack = [];&#125;;/** * Create `router.verb()` methods, where *verb* is one of the HTTP verbs such * as `router.get()` or `router.post()`. * * Match URL patterns to callback functions or controller actions using `router.verb()`, * where **verb** is one of the HTTP verbs such as `router.get()` or `router.post()`. * * Additionaly, `router.all()` can be used to match against all methods. * * ```javascript * router * .get('/', function (ctx, next) &#123; * ctx.body = 'Hello World!'; * &#125;) * .post('/users', function (ctx, next) &#123; * // ... * &#125;) * .put('/users/:id', function (ctx, next) &#123; * // ... * &#125;) * .del('/users/:id', function (ctx, next) &#123; * // ... * &#125;) * .all('/users/:id', function (ctx, next) &#123; * // ... * &#125;); * ``` * * When a route is matched, its path is available at `ctx._matchedRoute` and if named, * the name is available at `ctx._matchedRouteName` * * Route paths will be translated to regular expressions using * [path-to-regexp](https://github.com/pillarjs/path-to-regexp). * * Query strings will not be considered when matching requests. * * #### Named routes * * Routes can optionally have names. This allows generation of URLs and easy * renaming of URLs during development. * * ```javascript * router.get('user', '/users/:id', function (ctx, next) &#123; * // ... * &#125;); * * router.url('user', 3); * // =&gt; \"/users/3\" * ``` * * #### Multiple middleware * * Multiple middleware may be given: * * ```javascript * router.get( * '/users/:id', * function (ctx, next) &#123; * return User.findOne(ctx.params.id).then(function(user) &#123; * ctx.user = user; * next(); * &#125;); * &#125;, * function (ctx) &#123; * console.log(ctx.user); * // =&gt; &#123; id: 17, name: \"Alex\" &#125; * &#125; * ); * ``` * * ### Nested routers * * Nesting routers is supported: * * ```javascript * var forums = new Router(); * var posts = new Router(); * * posts.get('/', function (ctx, next) &#123;...&#125;); * posts.get('/:pid', function (ctx, next) &#123;...&#125;); * forums.use('/forums/:fid/posts', posts.routes(), posts.allowedMethods()); * * // responds to \"/forums/123/posts\" and \"/forums/123/posts/123\" * app.use(forums.routes()); * ``` * * #### Router prefixes * * Route paths can be prefixed at the router level: * * ```javascript * var router = new Router(&#123; * prefix: '/users' * &#125;); * * router.get('/', ...); // responds to \"/users\" * router.get('/:id', ...); // responds to \"/users/:id\" * ``` * * #### URL parameters * * Named route parameters are captured and added to `ctx.params`. * * ```javascript * router.get('/:category/:title', function (ctx, next) &#123; * console.log(ctx.params); * // =&gt; &#123; category: 'programming', title: 'how-to-node' &#125; * &#125;); * ``` * * The [path-to-regexp](https://github.com/pillarjs/path-to-regexp) module is * used to convert paths to regular expressions. * * @name get|put|post|patch|delete|del * @memberof module:koa-router.prototype * @param &#123;String&#125; path * @param &#123;Function=&#125; middleware route middleware(s) * @param &#123;Function&#125; callback route callback * @returns &#123;Router&#125; */// 注册注册路由的方法 router.get,router.post ......methods.forEach(function (method) &#123; Router.prototype[method] = function (name, path, middleware) &#123; var middleware; if (typeof path === 'string' || path instanceof RegExp) &#123; middleware = Array.prototype.slice.call(arguments, 2); &#125; else &#123; middleware = Array.prototype.slice.call(arguments, 1); path = name; name = null; &#125; this.register(path, [method], middleware, &#123; name: name &#125;); return this; &#125;;&#125;);// Alias for `router.delete()` because delete is a reserved wordRouter.prototype.del = Router.prototype['delete'];/** * Use given middleware. * * Middleware run in the order they are defined by `.use()`. They are invoked * sequentially, requests start at the first middleware and work their way * \"down\" the middleware stack. * * @example * * ```javascript * // session middleware will run before authorize * router * .use(session()) * .use(authorize()); * * // use middleware only with given path * router.use('/users', userAuth()); * * // or with an array of paths * router.use(['/users', '/admin'], userAuth()); * * app.use(router.routes()); * ``` * * @param &#123;String=&#125; path * @param &#123;Function&#125; middleware * @param &#123;Function=&#125; ... * @returns &#123;Router&#125; */// 注册路由中间件Router.prototype.use = function () &#123; var router = this; var middleware = Array.prototype.slice.call(arguments); var path = '(.*)'; // support array of paths // 如果是数组，router.use(['/users', '/admin'],middleware1,middleware2) // 对'/users','/admin' 依次调用 router.use(path,middleware,middleware2) // 简单的说就是专为单路由调用 if (Array.isArray(middleware[0]) &amp;&amp; typeof middleware[0][0] === 'string') &#123; middleware[0].forEach(function (p) &#123; router.use.apply(router, [p].concat(middleware.slice(1))); &#125;); return this; &#125; //如果第一个是path，弹出path var hasPath = typeof middleware[0] === 'string'; if (hasPath) &#123; path = middleware.shift(); &#125; middleware.forEach(function (m) &#123; // 如果有router,表明是router.routes()返回的中间件, // 调用形式大致如 parentRouter.use('/parent-route', nestedRouter.routes()) if (m.router) &#123; m.router.stack.forEach(function (nestedLayer) &#123; // 子路由的前缀 if (path) nestedLayer.setPrefix(path); // 父路由的前缀，因为parentRouter本身可能有前缀 if (router.opts.prefix) nestedLayer.setPrefix(router.opts.prefix); // router.stack存一份更新后的路由引用 router.stack.push(nestedLayer); &#125;); // 参数验证中间件添加给 m.router 来一份 if (router.params) &#123; // 参数验证中间件添加给 m.router 来一份 // 保证在调用子路由的时候，也验证参数,看看param方法，实际上是Router实例把参数验证中间件传给每一个路由(Layer) // m.router.stack就是存放路由(Layer)的数组 //Router.prototype.param = function (param, middleware) &#123; // this.params[param] = middleware; // this.stack.forEach(function (route) &#123; // route.param(param, middleware); // &#125;); // return this; //&#125;; Object.keys(router.params).forEach(function (key) &#123; m.router.param(key, router.params[key]); &#125;); &#125; &#125; else &#123; // 如果不是路由中间件,注册新的中间件 router.register(path, [], m, &#123; end: false, ignoreCaptures: !hasPath &#125;); &#125; &#125;); return this;&#125;;/** * Set the path prefix for a Router instance that was already initialized. * 给router实例添加前缀 * @example * * ```javascript * router.prefix('/things/:thing_id') * ``` * * @param &#123;String&#125; prefix * @returns &#123;Router&#125; */Router.prototype.prefix = function (prefix) &#123; prefix = prefix.replace(/\\/$/, ''); this.opts.prefix = prefix; this.stack.forEach(function (route) &#123; route.setPrefix(prefix); &#125;); return this;&#125;;/** * Returns router middleware which dispatches a route matching the request. * 生成路由中间件 * @returns &#123;Function&#125; */Router.prototype.routes = Router.prototype.middleware = function () &#123; var router = this; var dispatch = function dispatch(ctx, next) &#123; debug('%s %s', ctx.method, ctx.path); var path = router.opts.routerPath || ctx.routerPath || ctx.path; var matched = router.match(path, ctx.method); var layerChain, layer, i; if (ctx.matched) &#123; // 多个router有match上 ctx.matched.push.apply(ctx.matched, matched.path); &#125; else &#123; ctx.matched = matched.path; &#125; // router指向当前router ctx.router = router; // 没匹配，下一个中间件 if (!matched.route) return next(); var matchedLayers = matched.pathAndMethod var mostSpecificLayer = matchedLayers[matchedLayers.length - 1] ctx._matchedRoute = mostSpecificLayer.path; if (mostSpecificLayer.name) &#123; ctx._matchedRouteName = mostSpecificLayer.name; &#125; // 添加参数中间件，一个变两， layerChain = matchedLayers.reduce(function(memo, layer) &#123; // 解析参数和参数值 memo.push(function(ctx, next) &#123; ctx.captures = layer.captures(path, ctx.captures); // 参数会叠加，比如 '/user/:id' '/user/:id/post/:pid' // id和pid的值都会被映射到 ctx.params上 // 有人会说，我一般ctx.body就完事了，你试试修改router的匹配规则和和调用next()试// 试就知道了 ctx.params = layer.params(path, ctx.captures, ctx.params); return next(); &#125;); return memo.concat(layer.stack); &#125;, []); //执行 return compose(layerChain)(ctx, next); &#125;; // 保存对router的引用，在use里面也用来是被是不是路由中间件 dispatch.router = this; return dispatch;&#125;;/** * Returns separate middleware for responding to `OPTIONS` requests with * an `Allow` header containing the allowed methods, as well as responding * with `405 Method Not Allowed` and `501 Not Implemented` as appropriate. * * @example * * ```javascript * var Koa = require('koa'); * var Router = require('koa-router'); * * var app = new Koa(); * var router = new Router(); * * app.use(router.routes()); * app.use(router.allowedMethods()); * ``` * * **Example with [Boom](https://github.com/hapijs/boom)** * * ```javascript * var Koa = require('koa'); * var Router = require('koa-router'); * var Boom = require('boom'); * * var app = new Koa(); * var router = new Router(); * * app.use(router.routes()); * app.use(router.allowedMethods(&#123; * throw: true, * notImplemented: () =&gt; new Boom.notImplemented(), * methodNotAllowed: () =&gt; new Boom.methodNotAllowed() * &#125;)); * ``` * * @param &#123;Object=&#125; options * @param &#123;Boolean=&#125; options.throw throw error instead of setting status and header * @param &#123;Function=&#125; options.notImplemented throw the returned value in place of the default NotImplemented error * @param &#123;Function=&#125; options.methodNotAllowed throw the returned value in place of the default MethodNotAllowed error * @returns &#123;Function&#125; */Router.prototype.allowedMethods = function (options) &#123; options = options || &#123;&#125;; var implemented = this.methods; return function allowedMethods(ctx, next) &#123; return next().then(function() &#123; var allowed = &#123;&#125;; // 获得所有支持的方法 if (!ctx.status || ctx.status === 404) &#123; ctx.matched.forEach(function (route) &#123; route.methods.forEach(function (method) &#123; allowed[method] = method; &#125;); &#125;); var allowedArr = Object.keys(allowed); //未实现 if (!~implemented.indexOf(ctx.method)) &#123; if (options.throw) &#123; var notImplementedThrowable; if (typeof options.notImplemented === 'function') &#123; notImplementedThrowable = options.notImplemented(); // set whatever the user returns from their function &#125; else &#123; notImplementedThrowable = new HttpError.NotImplemented(); &#125; throw notImplementedThrowable; &#125; else &#123; ctx.status = 501; ctx.set('Allow', allowedArr); &#125; &#125; else if (allowedArr.length) &#123; // 如果length &gt; 0表示有路由匹配 if (ctx.method === 'OPTIONS') &#123; ctx.status = 200; ctx.body = ''; ctx.set('Allow', allowedArr); &#125; else if (!allowed[ctx.method]) &#123; //对应请求方式不被允许，比如post请求只定义了get方法的路由 if (options.throw) &#123; var notAllowedThrowable; if (typeof options.methodNotAllowed === 'function') &#123; notAllowedThrowable = options.methodNotAllowed(); // set whatever the user returns from their function &#125; else &#123; notAllowedThrowable = new HttpError.MethodNotAllowed(); &#125; throw notAllowedThrowable; &#125; else &#123; ctx.status = 405; ctx.set('Allow', allowedArr); &#125; &#125; &#125; &#125; &#125;); &#125;;&#125;;/** * Register route with all methods. * * @param &#123;String&#125; name Optional. * @param &#123;String&#125; path * @param &#123;Function=&#125; middleware You may also pass multiple middleware. * @param &#123;Function&#125; callback * @returns &#123;Router&#125; * @private */Router.prototype.all = function (name, path, middleware) &#123; var middleware; if (typeof path === 'string') &#123; middleware = Array.prototype.slice.call(arguments, 2); &#125; else &#123; middleware = Array.prototype.slice.call(arguments, 1); path = name; name = null; &#125; this.register(path, methods, middleware, &#123; name: name &#125;); return this;&#125;;/** * Redirect `source` to `destination` URL with optional 30x status `code`. * * Both `source` and `destination` can be route names. * * ```javascript * router.redirect('/login', 'sign-in'); * ``` * * This is equivalent to: * * ```javascript * router.all('/login', function (ctx) &#123; * ctx.redirect('/sign-in'); * ctx.status = 301; * &#125;); * ``` * * @param &#123;String&#125; source URL or route name. * @param &#123;String&#125; destination URL or route name. * @param &#123;Number&#125; code HTTP status code (default: 301). * @returns &#123;Router&#125; */Router.prototype.redirect = function (source, destination, code) &#123; // lookup source route by name if (source[0] !== '/') &#123; source = this.url(source); &#125; // lookup destination route by name if (destination[0] !== '/') &#123; destination = this.url(destination); &#125; return this.all(source, function (ctx) &#123; ctx.redirect(destination); ctx.status = code || 301; &#125;);&#125;;/** * Create and register a route. * * @param &#123;String&#125; path Path string. * @param &#123;Array.&lt;String&gt;&#125; methods Array of HTTP verbs. * @param &#123;Function&#125; middleware Multiple middleware also accepted. * @returns &#123;Layer&#125; * @private */Router.prototype.register = function (path, methods, middleware, opts) &#123; opts = opts || &#123;&#125;; var router = this; var stack = this.stack; // support array of paths // 数组挨个调用register if (Array.isArray(path)) &#123; path.forEach(function (p) &#123; router.register.call(router, p, methods, middleware, opts); &#125;); return this; &#125; // create route var route = new Layer(path, methods, middleware, &#123; end: opts.end === false ? opts.end : true, name: opts.name, sensitive: opts.sensitive || this.opts.sensitive || false, strict: opts.strict || this.opts.strict || false, prefix: opts.prefix || this.opts.prefix || \"\", ignoreCaptures: opts.ignoreCaptures &#125;); if (this.opts.prefix) &#123; route.setPrefix(this.opts.prefix); &#125; // add parameter middleware Object.keys(this.params).forEach(function (param) &#123; route.param(param, this.params[param]); &#125;, this); stack.push(route); return route;&#125;;/** * Lookup route with given `name`. * 查找具名的route * @param &#123;String&#125; name * @returns &#123;Layer|false&#125; */Router.prototype.route = function (name) &#123; var routes = this.stack; for (var len = routes.length, i=0; i&lt;len; i++) &#123; if (routes[i].name &amp;&amp; routes[i].name === name) &#123; return routes[i]; &#125; &#125; return false;&#125;;/** * Generate URL for route. Takes a route name and map of named `params`. * * @example * * ```javascript * router.get('user', '/users/:id', function (ctx, next) &#123; * // ... * &#125;); * * router.url('user', 3); * // =&gt; \"/users/3\" * * router.url('user', &#123; id: 3 &#125;); * // =&gt; \"/users/3\" * * router.use(function (ctx, next) &#123; * // redirect to named route * ctx.redirect(ctx.router.url('sign-in')); * &#125;) * ``` * * @param &#123;String&#125; name route name * @param &#123;Object&#125; params url parameters * @returns &#123;String|Error&#125; */Router.prototype.url = function (name, params) &#123; var route = this.route(name); if (route) &#123; var args = Array.prototype.slice.call(arguments, 1); return route.url.apply(route, args); &#125; return new Error(\"No route found for name: \" + name);&#125;;/** * Match given `path` and return corresponding routes. * * @param &#123;String&#125; path * @param &#123;String&#125; method * @returns &#123;Object.&lt;path, pathAndMethod&gt;&#125; returns layers that matched path and * path and method. * @private */Router.prototype.match = function (path, method) &#123; var layers = this.stack; var layer; var matched = &#123; path: [], pathAndMethod: [], route: false &#125;; for (var len = layers.length, i = 0; i &lt; len; i++) &#123; layer = layers[i]; debug('test %s %s', layer.path, layer.regexp); if (layer.match(path)) &#123; matched.path.push(layer); // layer 未指定methods，相当于any,或者包含该方法 ~ 取反值，并-1，只有 -1时 ~-1 === 0 if (layer.methods.length === 0 || ~layer.methods.indexOf(method)) &#123; matched.pathAndMethod.push(layer); if (layer.methods.length) matched.route = true; &#125; &#125; &#125; return matched;&#125;;/** * Run middleware for named route parameters. Useful for auto-loading or * validation. * * @example * * ```javascript * router * .param('user', function (id, ctx, next) &#123; * ctx.user = users[id]; * if (!ctx.user) return ctx.status = 404; * return next(); * &#125;) * .get('/users/:user', function (ctx) &#123; * ctx.body = ctx.user; * &#125;) * .get('/users/:user/friends', function (ctx) &#123; * return ctx.user.getFriends().then(function(friends) &#123; * ctx.body = friends; * &#125;); * &#125;) * // /users/3 =&gt; &#123;\"id\": 3, \"name\": \"Alex\"&#125; * // /users/3/friends =&gt; [&#123;\"id\": 4, \"name\": \"TJ\"&#125;] * ``` * * @param &#123;String&#125; param * @param &#123;Function&#125; middleware * @returns &#123;Router&#125; */Router.prototype.param = function (param, middleware) &#123; this.params[param] = middleware; this.stack.forEach(function (route) &#123; route.param(param, middleware); &#125;); return this;&#125;;/** * Generate URL from url pattern and given `params`. * * @example * * ```javascript * var url = Router.url('/users/:id', &#123;id: 1&#125;); * =&gt; \"/users/1\" * @param {String} path url pattern @param {Object} params url parameters @returns {String}*/Router.url = function (path, params) { return Layer.prototype.url.call({path: path}, params);};```","categories":[{"name":"源码","slug":"源码","permalink":"https://xiangwenhu.github.io/categories/源码/"}],"tags":[{"name":"koa-router","slug":"koa-router","permalink":"https://xiangwenhu.github.io/tags/koa-router/"}]},{"title":"koa-router Layer源码分析","slug":"sourecode/koa-router-layer","date":"2017-08-22T14:00:00.000Z","updated":"2017-08-23T05:29:17.839Z","comments":true,"path":"2017/08/22/sourecode/koa-router-layer/","link":"","permalink":"https://xiangwenhu.github.io/2017/08/22/sourecode/koa-router-layer/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247var debug = require('debug')('koa-router');var pathToRegExp = require('path-to-regexp');module.exports = Layer;/** * Initialize a new routing Layer with given `method`, `path`, and `middleware`. * * @param &#123;String|RegExp&#125; path Path string or regular expression. * @param &#123;Array&#125; methods Array of HTTP verbs. * @param &#123;Array&#125; middleware Layer callback/middleware or series of. * @param &#123;Object=&#125; opts * @param &#123;String=&#125; opts.name route name * @param &#123;String=&#125; opts.sensitive case sensitive (default: false) * @param &#123;String=&#125; opts.strict require the trailing slash (default: false) * @returns &#123;Layer&#125; * @private */function Layer(path, methods, middleware, opts) &#123; this.opts = opts || &#123;&#125;; this.name = this.opts.name || null; this.methods = []; this.paramNames = []; // 中间件 this.stack = Array.isArray(middleware) ? middleware : [middleware]; // 方法转为小写 methods.forEach(function(method) &#123; var l = this.methods.push(method.toUpperCase()); if (this.methods[l-1] === 'GET') &#123; this.methods.unshift('HEAD'); &#125; &#125;, this); // ensure middleware is a function this.stack.forEach(function(fn) &#123; var type = (typeof fn); if (type !== 'function') &#123; throw new Error( methods.toString() + \" `\" + (this.opts.name || path) +\"`: `middleware` \" + \"must be a function, not `\" + type + \"`\" ); &#125; &#125;, this); this.path = path; // 从路径提取正则，效果如下：https://github.com/pillarjs/path-to-regexp, // var re = pathToRegexp('/foo/:bar', keys) =&gt; // re = /^\\/foo\\/([^\\/]+?)\\/?$/i // var re = pathToRegExp('/:foo/:bar/12/:tong/a',keys) =&gt; /^\\/((?:[^\\/]+?))\\/((?:[^\\/]+?))\\/12\\/((?:[^\\/]+?))\\/a(?:\\/(?=$))?$/i // // this.paramNames 格式如下 // [ &#123; name: 'foo', // prefix: '/', // delimiter: '/', // optional: false, // repeat: false, // partial: false, // asterisk: false, // pattern: '[^\\\\/]+?' &#125;, .....] this.regexp = pathToRegExp(path, this.paramNames, this.opts); debug('defined route %s %s', this.methods, this.opts.prefix + this.path);&#125;;/** * Returns whether request `path` matches route. * * @param &#123;String&#125; path * @returns &#123;Boolean&#125; * @private */Layer.prototype.match = function (path) &#123; return this.regexp.test(path);&#125;;/** * Returns map of URL parameters for given `path` and `paramNames`. * 获得路由参数键值对 * @param &#123;String&#125; path * @param &#123;Array.&lt;String&gt;&#125; captures * @param &#123;Object=&#125; existingParams * @returns &#123;Object&#125; * @private */Layer.prototype.params = function (path, captures, existingParams) &#123; var params = existingParams || &#123;&#125;; for (var len = captures.length, i=0; i&lt;len; i++) &#123; if (this.paramNames[i]) &#123; var c = captures[i]; params[this.paramNames[i].name] = c ? safeDecodeURIComponent(c) : c; &#125; &#125; return params;&#125;;/** * Returns array of regexp url path captures. * 返回各个参数的值 * '/foo/:bar', regexp = /^\\/foo\\/([^\\/]+?)\\/?$/i , '/foo/bar' 返回 [bar] *'/:foo/:bar/12/:tong/a', regexp = /^\\/((?:[^\\/]+?))\\/((?:[^\\/]+?))\\/12\\/((?:[^\\/]+?))\\/a(?:\\/(?=$))?$/i , '/foo/bar/12/tong/a' 返回 ['foo','var','tong'] * @param &#123;String&#125; path * @returns &#123;Array.&lt;String&gt;&#125; * @private */Layer.prototype.captures = function (path) &#123; if (this.opts.ignoreCaptures) return []; return path.match(this.regexp).slice(1);&#125;;/** * Generate URL for route using given `params`. * 用参数构建URL,params参数可视是对象也可是数组 * @example * * ```javascript * var route = new Layer(['GET'], '/users/:id', fn); * * route.url(&#123; id: 123 &#125;); // =&gt; \"/users/123\" * ``` * * @param &#123;Object&#125; params url parameters * @returns &#123;String&#125; * @private */Layer.prototype.url = function (params) &#123; var args = params; var url = this.path.replace('\\(\\.\\*\\)', ''); var toPath = pathToRegExp.compile(url); // argument is of form &#123; key: val &#125; if (typeof params != 'object') &#123; args = Array.prototype.slice.call(arguments); &#125; if (args instanceof Array) &#123; //如果是数组，转换为对象 var tokens = pathToRegExp.parse(url); var replace = &#123;&#125;; for (var len = tokens.length, i=0, j=0; i&lt;len; i++) &#123; // 有name，才是有效的参数，https://github.com/pillarjs/path-to-regexp#parse if (tokens[i].name) [tokens[i].name] = args[j++]; &#125; return toPath(replace); &#125; else &#123; return toPath(params); &#125;&#125;;/** * Run validations on route named parameters. * 验证具名参数 * @example * * ```javascript * router * .param('user', function (id, ctx, next) &#123; * ctx.user = users[id]; * if (!user) return ctx.status = 404; * next(); * &#125;) * .get('/users/:user', function (ctx, next) &#123; * ctx.body = ctx.user; * &#125;); * ``` * * @param &#123;String&#125; param * @param &#123;Function&#125; middleware * @returns &#123;Layer&#125; * @private */Layer.prototype.param = function (param, fn) &#123; var stack = this.stack; var params = this.paramNames; // 构建参数验证中间件 var middleware = function (ctx, next) &#123; return fn.call(this, ctx.params[param], ctx, next); &#125;; middleware.param = param; var names = params.map(function (p) &#123; return p.name; &#125;); var x = names.indexOf(param); if (x &gt; -1) &#123; // iterate through the stack, to figure out where to place the handler fn stack.some(function (fn, i) &#123; // param handlers are always first, so when we find an fn w/o a param property, stop here // if the param handler at this part of the stack comes after the one we are adding, stop here // fn.param 作为判断是不是参数验证中间件的标志 // 如果不是参数验证中间件，或者参数验证中间件需要验证的参数在我之后，插入参数验证中间件 // 比如说path是这样的 /user/:id/posts/:postid, 那么id参数验证中间件应该在postid参数之前 // 简单说，确保参数按照顺序被验证 if (!fn.param || names.indexOf(fn.param) &gt; x) &#123; // inject this param handler right before the current item stack.splice(i, 0, middleware); return true; // then break the loop &#125; &#125;); &#125; return this;&#125;;/** * Prefix route path. * 设置路由前缀，https://github.com/alexmingoia/koa-router/tree/master/#router-prefixes * @param &#123;String&#125; prefix * @returns &#123;Layer&#125; * @private */Layer.prototype.setPrefix = function (prefix) &#123; if (this.path) &#123; this.path = prefix + this.path; this.paramNames = []; this.regexp = pathToRegExp(this.path, this.paramNames, this.opts); &#125; return this;&#125;;/** * Safe decodeURIComponent, won't throw any error. * If `decodeURIComponent` error happen, just return the original value. * * @param &#123;String&#125; text * @returns &#123;String&#125; URL decode original string. * @private */function safeDecodeURIComponent(text) &#123; try &#123; return decodeURIComponent(text); &#125; catch (e) &#123; return text; &#125;&#125;","categories":[{"name":"源码","slug":"源码","permalink":"https://xiangwenhu.github.io/categories/源码/"}],"tags":[{"name":"koa-router","slug":"koa-router","permalink":"https://xiangwenhu.github.io/tags/koa-router/"}]},{"title":"Hexo + Github搭建自己的博客","slug":"other/blogwithhexo","date":"2017-08-19T14:00:00.000Z","updated":"2017-08-24T07:14:58.097Z","comments":true,"path":"2017/08/19/other/blogwithhexo/","link":"","permalink":"https://xiangwenhu.github.io/2017/08/19/other/blogwithhexo/","excerpt":"","text":"如题，Hexo + Github搭建自己的博客，本博客就是如此搭建的，当前是 Hexo + Github pages + disqus + 不蒜子 网上有很多，我这里推荐 hexo从零开始到搭建完整和Hexo博客添加SEO-评论系统-阅读统计-站长统计已经基本满足你的需求，我这里主要是记录一些链接地址和自己在弄得时候遇到的一些问题。 我这里是windows，请注意，请注意步骤， 安装Git Bash Git for Window 安装NodeJs Node.js 建议使用最新版本 创建github仓库 github 安装Hexo 安装完毕后，务必查看官方文档， Hexo 文档|Hexo 指令|Hexo Themes|Hexo 配置|Hexo 变量|Hexo 配置还是有一些小问题的，官方在[配置|Hexo]里面提到 12如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 我的情况也是如此，可是配置过后，Share和留言的url并不是正确的，缺少 blog这一段路径，没有办法，自己做了一些修改 , 主要是修改了 post.permalink 为 config.url + config.root + post.path 和 url_for(post.path) 1234567&lt;footer class=&quot;article-footer&quot;&gt; &lt;a data-url=&quot;&lt;%- config.url + config.root + post.path %&gt;&quot; data-id=&quot;&lt;%= post._id %&gt;&quot; class=&quot;article-share-link&quot;&gt;&lt;%= __(&apos;share&apos;) %&gt;&lt;/a&gt; &lt;% if (post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;#disqus_thread&quot; class=&quot;article-comment-link&quot;&gt;&lt;%= __(&apos;comment&apos;) %&gt;&lt;/a&gt; &lt;% &#125; %&gt; &lt;%- partial(&apos;post/tag&apos;) %&gt;&lt;/footer&gt; Theme默认 hexo init的时候是landscape，你可以到 Themes|Hexo去选择自己喜欢的，下载下来修改配置就行。 Hexo主要的配置都在_config.yml里面，语法都是 属性名:[空格]值,参考: 配置|Hexo Hexo 是支持本地调试的执行 hexo server，默认端口是4000, http://localhost:4000, 有时候本地调试一些东西，因为cors策略，是没法调试通的，怎么办，修改host啊 Hexo 是支持直接发布的，hexo deploy,这个需要你配置ssh，hexo从零开始到搭建完整里面有提到，可以参考git ssh配置和使用 博客编写是在 souce/_post下面，默认是直接在这下面的，你可以自己再创建目录 博客的日期默认应该是文件创建日期，曾有人说过，换电脑后，全部为同一天了，怎么解决，在你的博客头部添加date, 如下，更多变量查看变量|Hexo 1234567---title: Hexo + Github搭建自己的博客categories: githubtag: [github,blog]date: 2017-08-19 22:00:00comments: true--- 5.添加评论功能评论插件,多说和网易云跟帖阵亡 ,更多查看第三方评论系统推荐disqus来必力畅言友言gitmentQingQing我选择disqus别问我为什么，具体可以参考GithubPages + Hexo + Disqus博客教程 6.统计Google AnalysisCNZZ百度统计leancloud不蒜子related-popular-posts我选择不蒜子，具体参考不蒜子 更换theme在Themes|Hexo 找到你喜欢的Theme，点击图是预览，点击下面的文字是进入对应的github仓库。我更换到 hueman 打开本地项目，执行git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman 用IDE打开 themes/hueman/_config.yml.example,去掉后缀.example 修改_config.yml,参考Configuration hueman 自带是支持disqus评论功能，只需修改_config.yml配置disqus_shortname就行，如没有就添加，本身是支持 disqus,多说,isso,facebook,友言，畅言的 hueman 默认的首页，每个博客是带图片的，你可以打开themes/hueman/_config.yml修改customize:thumbnail 有时候，你觉得内容展示区域太小了，怎么办，打开themes/hueman/source/css/_variables.styl,找到 container-inner-max-width，默认是1100多，我修改为80% ,在高分辨下，可能会有更好的效果 支持搜索，简直没话说，具体参考Search · ppoffice/hexo-theme-hueman Wiki 你会发现搜索有个图标，但是点击确没有反应，我不喜欢，找到 themes/hueman/source/js/insight.js,大约220行修改$(document).on(&#39;click focus&#39;, &#39;.search-form-input&#39; 为 $(document).on(&#39;click focus&#39;, &#39;.search-form&#39;，就好了 代码高亮，hueman用的是HighLight.js,支持的语言可以参考Css Classes Reference,这些在Theme | Hueman 有提到 hexo是支持资源文件的，分 Global Asset Foler 和 POST ASSET Folder, 实现原理居然是每个Post创建一个文件夹，有点醉，具体可以看Asset Folders hexo20分钟教你使用hexo搭建github博How to setup a blog on github with Hexo使用Hexo &amp; Github,搭建属于自己的博客给hexo配置上评论和访问量hexo从零开始到搭建完整Hexo博客添加SEO-评论系统-阅读统计-站长统计统计访问次数不蒜子hexo-related-popular-postsHexo统计post阅读次数使用LeanCloud平台为Hexo博客添加文章浏览量统计组件leancloudleancloudLeanCloud JavaScript SDK其他搭建个人博客，你需要知道这些Hexo搭建博客之博客搜索引擎推广将hexo博客（github pages）同时同步托管到github和coding.net,解决百度不收录问题Able to push to all git remotes with the one command? 来必力QingQing","categories":[{"name":"其他","slug":"其他","permalink":"https://xiangwenhu.github.io/categories/其他/"},{"name":"github","slug":"其他/github","permalink":"https://xiangwenhu.github.io/categories/其他/github/"}],"tags":[{"name":"github","slug":"github","permalink":"https://xiangwenhu.github.io/tags/github/"}]},{"title":"一些链接","slug":"other/links","date":"2017-08-16T08:00:00.000Z","updated":"2017-08-21T01:48:45.919Z","comments":true,"path":"2017/08/16/other/links/","link":"","permalink":"https://xiangwenhu.github.io/2017/08/16/other/links/","excerpt":"","text":"Corew3cw3c TRMDNCan I UseBrowse test cases · jsPerfChrome 开发者工具 | Web | Google DevelopersCompatibility overview 学习站点掘金妙味课堂前端网FreeCodeCamp前端乱炖CodePen极客学院 HTML教程|菜鸟教程CSS参考手册_web前端开发参考手册系列ECMAScript 6 入门廖雪峰Javascript教程It 浪人开发者头条 领域web component 团队腾讯ISUX首页 - 美团点评技术团队 测试WebPagetest - Website Performance and Optimization Test npmpackage.json | npm documentpackage.json文件 IDEDocumentation for Visual Studio Code GitRuan YiFeng叶小钗司徒正美张云龙 常用代码收集资源分享node lessons全栈增长工程师指南 其他最全前端资源汇集前端开发者手册编码规范","categories":[{"name":"其他","slug":"其他","permalink":"https://xiangwenhu.github.io/categories/其他/"},{"name":"资源","slug":"其他/资源","permalink":"https://xiangwenhu.github.io/categories/其他/资源/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiangwenhu.github.io/tags/前端/"}]},{"title":"chrome中间件","slug":"other/plugins","date":"2017-08-15T05:00:00.000Z","updated":"2017-08-21T01:48:45.919Z","comments":true,"path":"2017/08/15/other/plugins/","link":"","permalink":"https://xiangwenhu.github.io/2017/08/15/other/plugins/","excerpt":"","text":"chrome的扩展分三层次，components, extensions,apps, 均可打开chrome浏览器，输入如下命令查看chrome://appschrome://extensionschrome://components","categories":[{"name":"其他","slug":"其他","permalink":"https://xiangwenhu.github.io/categories/其他/"},{"name":"浏览器","slug":"其他/浏览器","permalink":"https://xiangwenhu.github.io/categories/其他/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://xiangwenhu.github.io/tags/浏览器/"}]},{"title":"markdown语法","slug":"other/markdown","date":"2017-08-10T02:00:00.000Z","updated":"2017-08-21T01:48:45.919Z","comments":true,"path":"2017/08/10/other/markdown/","link":"","permalink":"https://xiangwenhu.github.io/2017/08/10/other/markdown/","excerpt":"","text":"1. 图片语法![Alt text](/path/to/img.jpg &quot;Optional title&quot;)示例![Foo](http://i.weather.com.cn/images/cn/life/2017/04/11/11141533DF572FBBA092E37E6E843C656C318272.jpg) 2. 换行在文本中输入的换行会从最终生成的结果中删除，浏览器会根据可用空间自动换行。如果想强迫换行，可以在行尾插入至少两个空格。 3.强调语法**text** 或者 _text_示例**这是重点** 显示为 这是重点_这是重点_ 显示为 这是重点*这是重点* 显示为 这是重点 4. 标题可以在标题内容前输入特定数量的井号(‘#’)来实现对应级别的HTML样式的标题(HTML提供六级标题)语法## text注意，有空格，#一个就是H1，类推 ,需要独占一行# 标题1 显示为 标题15.引用语法&gt; text需要单独一行， &gt;可以多个出现示例&gt; 引用信息 显示为 引用信息 6.链接语法[链接文字](链接地址)和图片非常相似，少一个 !符号 7.水平分区线要生成水平分区线，可以在单独一行里输入3个或以上的短横线、星号或者下划线实现。短横线和星号之间可以输入任意空格。以下每一行都产生一条水平分区线。12345* * *********- - ---------------------------------------- 8.列表无序列表,如下是等同的1234567891011- Red- Green- Blue+ Red+ Green+ Blue- Red- Green- Blue 有序列表1231. Bird2. McHale3. Parish 9.删除线语法~~text~~示例~~text~~ 显示为 text 10.表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 显示为 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 其他：Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 如果是支持 table, |也是需要转移的，曾今发生过这样的尴尬 引用Markdown 维基百科markdown-syntax-zhtwMarkdown 语法说明 (简体中文版)Markdown 指南Markdown 语法","categories":[{"name":"其他","slug":"其他","permalink":"https://xiangwenhu.github.io/categories/其他/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://xiangwenhu.github.io/tags/前端/"}]},{"title":"cookie和session那点事","slug":"Network/c&s","date":"2017-08-09T05:00:00.000Z","updated":"2017-08-21T01:48:45.918Z","comments":true,"path":"2017/08/09/Network/c&s/","link":"","permalink":"https://xiangwenhu.github.io/2017/08/09/Network/c&s/","excerpt":"","text":"Cookie 和 Session那么一点事cookie最终还是存在磁盘上的，比如chrome的cookie存放位置C:\\Users\\你当前用户名\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\ 大家都知道document.cookie是可以读取和设置的，这就说明cookie是可以伪造的。不用怕， Secure和HttpOnly为你保驾护航，当然这两个是用在服务端的。 查看cookie可以设置的属性可以查看Set-Cookie - HTTP | MDN Secure属性：当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被窃取到Cookie 的具体内容。 HttpOnly属性：如果在Cookie中设置了”HttpOnly”属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。 借用知乎某个仁兄的话 cookie和session关联 session 在服务器端，cookie 在客户端（浏览器） session 默认被存在在服务器的一个文件里（不是内存） session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id） session 可以放在 文件、数据库、或内存中都可以。 用户验证这种场合一般会用 session 因此，维持一个会话的核心就是客户端的唯一标识，即 session id 额外的话 你从开发者工具，直接删除存在cookie里面的session id，刷新页面，session id是会更新的，被认为是新的会话，同理，你在某个网站登录了，强行删除session id，刷新页面会回到登录页面的。 存在cookie里面的session id 的key名字是可以修改的，曾今我们就发生过两个网站key值相同，会乱串，甚至会网站奔溃的情况 不同浏览器当然是不共享cookie的 cookie是每次http请求都会附带上的，所以尽量少 cookie同一个域名下的用户是共享cookie的 cookie是可以禁用的 cookie不允许跨域的，通过设置，二级域名可以使用 Set-Cookie - HTTP | MDN Cookie/Session机制详解禁止js获取sessionid常用的本地存储——cookie篇细说cookieCOOKIE和SESSION有什么区别","categories":[{"name":"其他","slug":"其他","permalink":"https://xiangwenhu.github.io/categories/其他/"},{"name":"网络","slug":"其他/网络","permalink":"https://xiangwenhu.github.io/categories/其他/网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://xiangwenhu.github.io/tags/网络/"}]},{"title":"koa源码分析","slug":"sourecode/koa","date":"2017-07-29T10:00:00.000Z","updated":"2017-08-23T05:54:37.124Z","comments":true,"path":"2017/07/29/sourecode/koa/","link":"","permalink":"https://xiangwenhu.github.io/2017/07/29/sourecode/koa/","excerpt":"","text":"在阅读文章之前，最好对koa(koa 2)有个基本的了解，最简单的方式从如下链接了解Koa - next generation web framework for node.jskoajs/koa: Expressive middleware for node.js using ES2017 async functionsKoa koa 源码结构 application.js 入口文件，导出 class Application `const Koa = require(&apos;koa&apos;);`,代码里面的Koa就是Application context.js 可以理解为中间件里面的ctx,比如如下的ctx 123app.use(async ctx =&gt; &#123; ctx.body = 'Hello World';&#125;); request对原生request的一些属性封装 response对原生response的一些属性封装 源码分析request.js都是返回一个对象，分别对原生request进行了封装，注意的是 this.req, 整个文件中并没有req的申明,其就是原生http中request对象的引用this.ctx 是对ctx的引用这个等到context.js和application.js再解释，1234567891011121314151617181920212223242526272829303132333435363738394041424344module.exports = &#123; /** * Return request header. * * @return &#123;Object&#125; * @api public */ get header() &#123; return this.req.headers; &#125;, ......``` ### response.js都是返回一个对象，分别对原生response进行了封装， 注意的是 this.res, 整个文件中并没有res的申明,其就是原生http中response对象的引用 this.ctx是对ctx的引用，这个等到context.js和application.js再解释，```javascriptmodule.exports = &#123; /** * Return the request socket. * * @return &#123;Connection&#125; * @api public */ get socket() &#123; return this.ctx.req.socket; &#125;, /** * Return response header. * * @return &#123;Object&#125; * @api public */ get header() &#123; const &#123; res &#125; = this; return typeof res.getHeaders === &apos;function&apos; ? res.getHeaders() : res._headers || &#123;&#125;; // Node &lt; 7.7 &#125;, ...... context.js本身不复杂，申请一个对象，然后调用delegate代理方法和属性妙就妙在这个 delegate，个人觉得是koa精髓之一123456789101112131415161718192021222324252627const createError = require('http-errors');const httpAssert = require('http-assert');const delegate = require('delegates');const statuses = require('statuses');const proto = module.exports = &#123; ......&#125;delegate(proto, 'response') .method('attachment') .method('redirect') .method('remove') .method('vary') .method('set') .method('append') .method('flushHeaders') .access('status') .access('message') .access('body') .access('length') .access('type') .access('lastModified') .access('etag') .getter('headerSent') .getter('writable'); ...... 我们来看一段delegates的源码, 源码在github的地址为 node delegates123456789101112131415161718192021222324252627282930/** * Initialize a delegator. * * @param &#123;Object&#125; proto * @param &#123;String&#125; target * @api public */function Delegator(proto, target) &#123; if (!(this instanceof Delegator)) return new Delegator(proto, target); this.proto = proto; this.target = target; this.methods = []; this.getters = []; this.setters = []; this.fluents = [];&#125;Delegator.prototype.method = function(name)&#123; var proto = this.proto; var target = this.target; this.methods.push(name); //添加方法， proto[name] = function()&#123; //实际执行的时候，是 proto target属性上的name方法 return this[target][name].apply(this[target], arguments); &#125;; return this;&#125;; 简单理解就是在proto上添加了一个方法，实际执行的时候是执行proto对象target属性上的方法，方法执行时的上下文是target属性那么回归我们的源码，context.js 那里面一堆的method,access,getter就是把request和response的方法在context在开了一个窗口，最终还是执行request和response的方法或者getter，setter最终的结果就是ctx有所有response和request的方法和getter,setter。主要是方便使用了。额外提一下delegate.access 表示可以读写delegate.setter 表示可以写delegate.getter 表示可以读 我们再来看一段 application.js的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445......const context = require('./context');......module.exports = class Application extends Emitter &#123; /** * Initialize a new `Application`. * * @api public */ constructor() &#123; super(); this.proxy = false; this.middleware = []; this.subdomainOffset = 2; this.env = process.env.NODE_ENV || 'development'; // ##1 this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); &#125; createContext(req, res) &#123; // ##2 const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, &#123; keys: this.keys, secure: request.secure &#125;); request.ip = request.ips[0] || req.socket.remoteAddress || ''; context.accept = request.accept = accepts(req); context.state = &#123;&#125;; return context; &#125; 注意##1，##2标记的地方，重点看 ##2，先看这3行123const context = Object.create(this.context);const request = context.request = Object.create(this.request);const response = context.response = Object.create(this.response); 先创建context,实际上这个时候，已经有request和repsonse的方法或者getter，setter了，但是光有这个不行啊，因为最终调用时 request和response的方法，第二三句代码就是添加request和response属性。 解析来看看这几句代码，就能解惑上面 response和request的疑问了123456context.app = request.app = response.app = this;context.req = request.req = response.req = req;context.res = request.res = response.res = res;request.ctx = response.ctx = context;request.response = response;response.request = request; ctx,request,response都有对app的引用，也是就是Koa()实例 ctx,request,response都有对原生request对象的引用 ctx,request,response都有对原生response对象的引用 request,response都有对content(ctx)的应用 request有对response的引用 response有对request的引用还是用一张图来说明吧 application.js删掉一些不重要的代码,仔细看注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180module.exports = class Application extends Emitter &#123; /** * Initialize a new `Application`. * * @api public */ constructor() &#123; super(); this.proxy = false; this.middleware = []; this.subdomainOffset = 2; this.env = process.env.NODE_ENV || &apos;development&apos;; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); &#125; /** * Shorthand for: * * http.createServer(app.callback()).listen(...) * * @param &#123;Mixed&#125; ... * @return &#123;Server&#125; * @api public */ listen() &#123; debug(&apos;listen&apos;); const server = http.createServer(this.callback()); return server.listen.apply(server, arguments); &#125; /** * Use the given middleware `fn`. * * Old-style middleware will be converted. * * @param &#123;Function&#125; fn * @return &#123;Application&#125; self * @api public */ use(fn) &#123; if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;); if (isGeneratorFunction(fn)) &#123; deprecate(&apos;Support for generators will be removed in v3. &apos; + &apos;See the documentation for examples of how to convert old middleware &apos; + &apos;https://github.com/koajs/koa/blob/master/docs/migration.md&apos;); fn = convert(fn); &#125; debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;); this.middleware.push(fn); return this; &#125; /** * Return a request handler callback * for node&apos;s native http server. * * @return &#123;Function&#125; * @api public */ callback() &#123; const fn = compose(this.middleware); //编译中间件 if (!this.listeners(&apos;error&apos;).length) this.on(&apos;error&apos;, this.onerror);//没有定义错误捕获，就采用默认的 const handleRequest = (req, res) =&gt; &#123; res.statusCode = 404; const ctx = this.createContext(req, res); const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fn(ctx).then(handleResponse).catch(onerror); &#125;; return handleRequest; &#125; /** * Initialize a new context. * * @api private */ createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, &#123; keys: this.keys, secure: request.secure &#125;); request.ip = request.ips[0] || req.socket.remoteAddress || &apos;&apos;; context.accept = request.accept = accepts(req); context.state = &#123;&#125;; return context; &#125; /** * Default error handler. * * @param &#123;Error&#125; err * @api private */ onerror(err) &#123; assert(err instanceof Error, `non-error thrown: $&#123;err&#125;`); if (404 == err.status || err.expose) return; if (this.silent) return; const msg = err.stack || err.toString(); console.error(); console.error(msg.replace(/^/gm, &apos; &apos;)); console.error(); &#125;&#125;;/** * Response helper. */function respond(ctx) &#123; // allow bypassing koa if (false === ctx.respond) return; const res = ctx.res; if (!ctx.writable) return; let body = ctx.body; const code = ctx.status; // ignore body if (statuses.empty[code]) &#123; // strip headers ctx.body = null; return res.end(); &#125; if (&apos;HEAD&apos; == ctx.method) &#123; if (!res.headersSent &amp;&amp; isJSON(body)) &#123; ctx.length = Buffer.byteLength(JSON.stringify(body)); &#125; return res.end(); &#125; // status body if (null == body) &#123; body = ctx.message || String(code); if (!res.headersSent) &#123; ctx.type = &apos;text&apos;; ctx.length = Buffer.byteLength(body); &#125; return res.end(body); &#125; // responses if (Buffer.isBuffer(body)) return res.end(body); if (&apos;string&apos; == typeof body) return res.end(body); if (body instanceof Stream) return body.pipe(res); // body: json body = JSON.stringify(body); if (!res.headersSent) &#123; ctx.length = Buffer.byteLength(body); &#125; res.end(body);&#125; listen是http.createServer(app.callback()).listen(…)的一种便捷调用形式要是网站使用https协议，那么就得https.createServer(credentials,capp.callback()).listen(…) use存中间件的信息，当然中间对采用generator实现的中间件进行了提示关于中间件里面的那个next，可以参看 koa2 中间件里面的next到底是什么 callback 核心之核心,主要工作 编译中间件， 错误函数定义 执行中间件， 对请求作出相应 如果有错误，错误处理 createContext构建中间件里面的ctxonerror默认错误捕捉函数respond实际作出相应的方法","categories":[{"name":"源码","slug":"源码","permalink":"https://xiangwenhu.github.io/categories/源码/"}],"tags":[{"name":"koa","slug":"koa","permalink":"https://xiangwenhu.github.io/tags/koa/"}]},{"title":"koa便签","slug":"sourecode/koa-note","date":"2017-07-29T05:00:00.000Z","updated":"2017-08-21T01:48:45.920Z","comments":true,"path":"2017/07/29/sourecode/koa-note/","link":"","permalink":"https://xiangwenhu.github.io/2017/07/29/sourecode/koa-note/","excerpt":"","text":"koa调用方式http123app.listen(3000);//等同于http.createServer(app.callback()).listen(3000); https1https.createServer(credentials, app.callback()).listen(3000) 一些相同引用或者属性koa实例app.toJSON == app.inspect requestctx.request.header == ctx.request.headers responsectx.response.header == ctx.response.headers koa实例 use方法use 返回的是this,也就是实例本身，那么就是可以连续useapp.use(middleware1).use(middleware2) app.use里面的ctx ctx.req保存了http里面原始的request对象 ctx.res保存了http里面原始的response对象 ctx.request.reponse保持对ctx.reponse引用, 也就是可以玩躲猫猫， ctx.request.reponse.request ctx.response.request保持对ctx.request引用 ctx 代理了所有request和response的方法，但是使用的时候，自己注意哪些属性能使用 ctx.originalUrl保存req.url,也就是原生request.url","categories":[{"name":"源码","slug":"源码","permalink":"https://xiangwenhu.github.io/categories/源码/"}],"tags":[{"name":"koa","slug":"koa","permalink":"https://xiangwenhu.github.io/tags/koa/"}]},{"title":"koa第三方中间件","slug":"sourecode/koa-3p","date":"2017-07-29T05:00:00.000Z","updated":"2017-08-21T01:48:45.920Z","comments":true,"path":"2017/07/29/sourecode/koa-3p/","link":"","permalink":"https://xiangwenhu.github.io/2017/07/29/sourecode/koa-3p/","excerpt":"","text":"kao一共引用了24个第三方包，其中我觉得比较喜欢的是 only，delegates我全部列在下面，一方面是方便自己查阅和参考，另一方面方便他人解读koa的时候，方便查看这些package是干嘛的 koa 引用的第三方package acceptsHigher-level content negotiation content-typeCreate and parse HTTP Content-Type header according to RFC 7231 content-dispositionCreate and parse HTTP Content-Disposition header cookiesCookies is a node.js module for getting and setting HTTP(S) cookies. Cookies can be signed to prevent tampering, using Keygrip. It can be used with the built-in node.js HTTP library, or as Connect/Express middleware. debugA tiny JavaScript debugging utility modelled after Node.js core’s debugging technique. Works in Node.js and web browsers. delegatesNode method and accessor delegation utilty depdDeprecate all the things destroyDestroy a stream.This module is meant to ensure a stream gets destroyed, handling different APIs and Node.js bugs. error-injectinject an error listener into a stream escape-htmlEscape string for use in HTML freshHTTP response freshness testing http-assertAssert with status codes. Like ctx.throw() in Koa, but with a guard http-errorsCreate HTTP errors for Express, Koa, Connect, etc. with ease is-generator-functionIs this a native generator function koa-composeCompose middleware koa-convertConvert koa legacy ( 0.x &amp; 1.x ) generator middleware to modern promise middleware ( 2.x ) koa-is-jsonCheck if a body is JSON mime-typesThe ultimate javascript content-type utility on-finishedExecute a callback when a HTTP request closes, finishes, or errors onlyReturn whitelisted properties of an object parseurlParse a URL with memoization statusesHTTP status utility for node type-isInfer the content-type of a request varyManipulate the HTTP Vary header","categories":[{"name":"源码","slug":"源码","permalink":"https://xiangwenhu.github.io/categories/源码/"}],"tags":[{"name":"koa","slug":"koa","permalink":"https://xiangwenhu.github.io/tags/koa/"}]}]}